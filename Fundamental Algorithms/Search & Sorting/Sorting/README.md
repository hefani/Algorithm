# Sorting Algorithms

This directory contains both classic and advanced sorting techniques with applied examples in algorithmic problem-solving. Sorting is a core component in many areas of computer science including optimization, graph theory, and computational geometry.

## Implemented Algorithms

| Algorithm       | Time Complexity | Notes |
|----------------|-----------------|-------|
| Bubble Sort     | O(n²)            | Educational use, not efficient |
| Insertion Sort  | O(n²)            | Efficient for nearly-sorted data |
| Selection Sort  | O(n²)            | Simple, but inefficient |
| Merge Sort      | O(n log n)       | Stable, divide-and-conquer |
| Quick Sort      | O(n log n) avg.  | In-place and fast, but unstable |
| Heap Sort       | O(n log n)       | Priority-queue based, rare in contests |

> **Note:** Heap sort is not frequently seen in competitive programming problems, but has been implemented here for completeness.

---

## Example Problems (from Codeforces)

These problems demonstrate the application of sorting in diverse algorithmic contexts beyond simple array manipulation.

| Problem | Tags |
|--------|------|
| [CF 1336A - Linova and Kingdom](https://codeforces.com/problemset/problem/1336/A) | Tree, DFS, Sorting, Greedy |
| [CF 1081D - Maximum Distance](https://codeforces.com/problemset/problem/1081/D) | Graphs, MST, Edge Sorting |
| [CF 863E - Turn Off The TV](https://codeforces.com/problemset/problem/863/E) | Sorting, Intervals, Geometry, Greedy |

---

## Objective

This section is designed to:
- Showcase a foundational understanding of sorting algorithms.
- Provide practical applications of sorting in real-world algorithmic challenges.
- Highlight flexibility in combining sorting with other domains (e.g., trees, graphs, geometry).

---

